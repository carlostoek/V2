"""
Handler para el men√∫ principal de gamificaci√≥n.
Centraliza el acceso a todas las funcionalidades de gamificaci√≥n.
"""

import logging
from aiogram import types, F
from aiogram.utils.keyboard import InlineKeyboardBuilder

from src.modules.gamification.service import GamificationService
from src.bot.keyboards.gamification.main_kb import GamificationKeyboard
from src.bot.database.engine import get_session
from src.bot.database.models.user import User
from src.bot.database.models.gamification import UserPoints
from sqlalchemy import select

logger = logging.getLogger(__name__)

async def handle_gamification_main(query: types.CallbackQuery, gamification_service: GamificationService):
    """
    Maneja el men√∫ principal de gamificaci√≥n.
    
    Args:
        query: Query del callback.
        gamification_service: Servicio que gestiona la gamificaci√≥n.
    """
    user_id = query.from_user.id
    
    try:
        # Obtener informaci√≥n del usuario
        user_info = await _get_user_gamification_info(user_id)
        if not user_info:
            await query.answer("‚ùå Error al cargar informaci√≥n de gamificaci√≥n.")
            return
        
        await _show_gamification_main_menu(query, user_info)
        
    except Exception as e:
        logger.error(f"Error en gamification main para usuario {user_id}: {e}")
        await query.answer("‚ùå Error al cargar el men√∫ de gamificaci√≥n.")

async def _get_user_gamification_info(user_id: int) -> dict:
    """
    Obtiene informaci√≥n completa del usuario para gamificaci√≥n.
    
    Args:
        user_id: ID del usuario.
        
    Returns:
        Dict con informaci√≥n del usuario.
    """
    async for session in get_session():
        # Obtener usuario
        user_query = select(User).where(User.id == user_id)
        user_result = await session.execute(user_query)
        user = user_result.scalars().first()
        
        if not user:
            return None
        
        # Obtener puntos
        points_query = select(UserPoints).where(UserPoints.user_id == user_id)
        points_result = await session.execute(points_query)
        user_points = points_result.scalars().first()
        
        current_points = user_points.current_points if user_points else 0
        
        # Verificar si puede reclamar regalo diario
        can_claim_daily = await _check_daily_reward_availability(user_points)
        
        return {
            "user_id": user_id,
            "level": user.level,
            "role": user.role,
            "current_points": current_points,
            "username": user.username or f"Usuario {user_id}",
            "can_claim_daily": can_claim_daily,
            "show_premium": user.role == "VIP" or user.level >= 5
        }

async def _check_daily_reward_availability(user_points) -> bool:
    """
    Verifica si el usuario puede reclamar recompensa diaria.
    
    Args:
        user_points: Objeto UserPoints del usuario.
        
    Returns:
        True si puede reclamar, False si no.
    """
    if not user_points or not user_points.points_history:
        return True
    
    from datetime import datetime, timedelta
    
    # Buscar √∫ltima recompensa diaria
    for entry in reversed(user_points.points_history):
        if entry.get("source") == "DailyReward":
            try:
                last_claim = datetime.fromisoformat(entry["timestamp"])
                time_since = datetime.now() - last_claim
                return time_since.total_seconds() >= 86400  # 24 horas
            except:
                continue
    
    return True

async def _show_gamification_main_menu(query: types.CallbackQuery, user_info: dict):
    """
    Muestra el men√∫ principal de gamificaci√≥n.
    
    Args:
        query: Query del callback.
        user_info: Informaci√≥n del usuario.
    """
    username = user_info["username"]
    level = user_info["level"]
    current_points = user_info["current_points"]
    can_claim_daily = user_info["can_claim_daily"]
    show_premium = user_info["show_premium"]
    
    # Crear mensaje principal
    text = (
        f"üéÆ **Centro de Gamificaci√≥n** üéÆ\n\n"
        f"üë§ {username} (Nivel {level})\n"
        f"üí∞ **{current_points:.0f} besitos** disponibles\n\n"
        "üéØ **¬øQu√© te gustar√≠a hacer hoy?**\n\n"
    )
    
    # Agregar informaci√≥n contextual
    if can_claim_daily:
        text += "üéÅ **¬°Tienes un regalo diario disponible!**\n"
    
    if level >= 5:
        text += "‚≠ê **Acceso VIP desbloqueado**\n"
    
    text += "\nSelecciona una opci√≥n del men√∫:"
    
    # Crear keyboard usando la clase especializada
    keyboard = GamificationKeyboard.main_menu(
        user_points=current_points,
        user_level=level,
        show_premium=show_premium
    )
    
    await query.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=keyboard
    )

async def handle_gamification_callback(query: types.CallbackQuery, gamification_service: GamificationService):
    """
    Maneja todos los callbacks del sistema de gamificaci√≥n.
    
    Args:
        query: Query del callback.
        gamification_service: Servicio que gestiona la gamificaci√≥n.
    """
    user_id = query.from_user.id
    callback_data = query.data
    
    try:
        parts = callback_data.split(":")
        action = parts[1]
        
        if action == "main":
            await handle_gamification_main(query, gamification_service)
        
        elif action == "daily_reward":
            # Redirigir al handler de daily rewards
            from src.bot.handlers.gamification.daily_rewards import handle_daily_reward
            await handle_daily_reward(query.message, gamification_service)
        
        elif action == "progress":
            await _show_progress_menu(query, gamification_service)
        
        elif action == "achievements":
            await _show_achievements_menu(query, gamification_service)
        
        elif action == "vip_zone":
            await _show_vip_zone(query, gamification_service)
        
        elif action == "settings":
            await _show_settings_menu(query)
        
        elif action.startswith("stats"):
            await _handle_stats_callback(query, parts, gamification_service)
        
        await query.answer()
        
    except Exception as e:
        logger.error(f"Error en gamification callback para usuario {user_id}: {e}")
        await query.answer("‚ùå Error al procesar la solicitud.")

async def _show_progress_menu(query: types.CallbackQuery, gamification_service: GamificationService):
    """
    Muestra el men√∫ de progreso del usuario.
    
    Args:
        query: Query del callback.
        gamification_service: Servicio de gamificaci√≥n.
    """
    user_id = query.from_user.id
    
    # Obtener informaci√≥n de progreso
    user_info = await _get_user_gamification_info(user_id)
    missions = await gamification_service.get_user_missions(user_id)
    achievements = await gamification_service.get_user_achievements(user_id)
    
    # Calcular estad√≠sticas
    total_missions = sum(len(missions[key]) for key in missions)
    completed_missions = len(missions["completed"])
    total_achievements = len(achievements["completed"]) + len(achievements["in_progress"])
    completed_achievements = len(achievements["completed"])
    
    text = (
        f"üìä **Tu Progreso en Diana** üìä\n\n"
        f"üéØ **Nivel:** {user_info['level']}\n"
        f"üí∞ **Besitos:** {user_info['current_points']:.0f}\n\n"
        f"**Misiones:**\n"
        f"‚úÖ Completadas: {completed_missions}\n"
        f"üîÑ En progreso: {len(missions['in_progress'])}\n"
        f"üìã Disponibles: {len(missions['available'])}\n\n"
        f"**Logros:**\n"
        f"üèÜ Conseguidos: {completed_achievements}/{total_achievements}\n\n"
        "Selecciona qu√© quieres ver en detalle:"
    )
    
    keyboard = GamificationKeyboard.progress_menu()
    
    await query.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=keyboard
    )

async def _show_achievements_menu(query: types.CallbackQuery, gamification_service: GamificationService):
    """
    Muestra el men√∫ de logros.
    
    Args:
        query: Query del callback.
        gamification_service: Servicio de gamificaci√≥n.
    """
    user_id = query.from_user.id
    
    achievements = await gamification_service.get_user_achievements(user_id)
    
    completed_count = len(achievements["completed"])
    progress_count = len(achievements["in_progress"])
    
    text = (
        f"üèÜ **Tus Logros** üèÜ\n\n"
        f"‚úÖ **Completados:** {completed_count}\n"
        f"üîÑ **En progreso:** {progress_count}\n\n"
        "Los logros te dan puntos extra y reconocimiento.\n"
        "¬°Sigue jugando para desbloquear m√°s!\n\n"
        "¬øQu√© logros quieres ver?"
    )
    
    keyboard = GamificationKeyboard.achievements_menu()
    
    await query.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=keyboard
    )

async def _show_vip_zone(query: types.CallbackQuery, gamification_service: GamificationService):
    """
    Muestra la zona VIP.
    
    Args:
        query: Query del callback.
        gamification_service: Servicio de gamificaci√≥n.
    """
    text = (
        f"‚≠ê **Zona VIP** ‚≠ê\n\n"
        f"¬°Bienvenido al √°rea exclusiva!\n\n"
        f"Aqu√≠ encontrar√°s:\n"
        f"üíé Contenido exclusivo premium\n"
        f"‚ö° Multiplicadores especiales\n"
        f"üëë Trivia de nivel experto\n"
        f"üéÅ Recompensas VIP √∫nicas\n"
        f"üìà Estad√≠sticas avanzadas\n\n"
        f"Selecciona lo que te interese:"
    )
    
    keyboard = GamificationKeyboard.vip_zone_menu()
    
    await query.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=keyboard
    )

async def _show_settings_menu(query: types.CallbackQuery):
    """
    Muestra el men√∫ de configuraciones.
    
    Args:
        query: Query del callback.
    """
    text = (
        f"‚öôÔ∏è **Configuraci√≥n de Gamificaci√≥n** ‚öôÔ∏è\n\n"
        f"Personaliza tu experiencia de juego:\n\n"
        f"üîî **Notificaciones** - Alertas de recompensas y logros\n"
        f"üéØ **Dificultad** - Nivel de desaf√≠o en trivia\n"
        f"üìä **Privacidad** - Control de estad√≠sticas p√∫blicas\n"
        f"üé® **Tema Visual** - Personalizaci√≥n de interfaz\n"
        f"üîÑ **Reset** - Reiniciar progreso (¬°cuidado!)\n\n"
        f"¬øQu√© quieres configurar?"
    )
    
    keyboard = GamificationKeyboard.settings_menu()
    
    await query.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=keyboard
    )

async def _handle_stats_callback(query: types.CallbackQuery, parts: list, gamification_service: GamificationService):
    """
    Maneja callbacks relacionados con estad√≠sticas.
    
    Args:
        query: Query del callback.
        parts: Partes del callback data.
        gamification_service: Servicio de gamificaci√≥n.
    """
    if len(parts) < 3:
        return
    
    stats_type = parts[2]
    user_id = query.from_user.id
    
    if stats_type == "general":
        user_points = await gamification_service.get_user_points(user_id)
        
        text = (
            f"üìä **Estad√≠sticas Generales** üìä\n\n"
            f"üí∞ **Besitos actuales:** {user_points['current_points']:.0f}\n"
            f"üìà **Total ganado:** {user_points['total_earned']:.0f}\n"
            f"üí∏ **Total gastado:** {user_points['total_spent']:.0f}\n"
            f"üéØ **Nivel:** {user_points['level']}\n"
            f"üìä **Progreso nivel:** {user_points['progress_to_next_level']:.1f}%\n\n"
            f"**Distribuci√≥n de puntos:**\n"
        )
        
        stats = user_points['stats']
        for category, points in stats.items():
            if points > 0:
                category_name = category.replace('from_', '').replace('_', ' ').title()
                text += f"‚ñ´Ô∏è {category_name}: {points:.0f}\n"
        
        keyboard = GamificationKeyboard.back_to_gamification()
        
        await query.message.edit_text(
            text,
            parse_mode="Markdown", 
            reply_markup=keyboard
        )

def register_gamification_main_handler(dp, gamification_service):
    """Registra el handler del men√∫ principal de gamificaci√≥n en el dispatcher."""
    # Callbacks de gamificaci√≥n
    dp.callback_query.register(
        lambda query: handle_gamification_callback(query, gamification_service),
        lambda c: c.data.startswith("gamification:")
    )