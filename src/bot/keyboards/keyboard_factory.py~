"""
Factory para la creaciÃ³n de teclados en el bot.

Este mÃ³dulo implementa el patrÃ³n Factory para la creaciÃ³n de
diferentes tipos de teclados, facilitando su reutilizaciÃ³n y
mantenimiento.
"""

from enum import Enum
from typing import List, Dict, Any, Optional, Union, Callable

from aiogram import types
from aiogram.utils.keyboard import InlineKeyboardBuilder, ReplyKeyboardBuilder

class KeyboardType(Enum):
    """Tipos de teclado disponibles en el sistema."""
    INLINE = "inline"
    REPLY = "reply"

class KeyboardFactory:
    """
    Factory para la creaciÃ³n de teclados.
    
    Esta clase facilita la creaciÃ³n de diferentes tipos de teclados
    siguiendo una estructura consistente.
    """
    
    @staticmethod
    def create_inline(
        buttons: List[List[Dict[str, str]]],
        width: Optional[int] = None,
        **kwargs
    ) -> types.InlineKeyboardMarkup:
        """
        Crea un teclado inline a partir de una matriz de botones.
        
        Args:
            buttons: Lista de filas de botones, donde cada botÃ³n es un diccionario
                    con 'text' y 'callback_data'.
            width: NÃºmero de botones por fila (si se utiliza la lista plana).
            **kwargs: Argumentos adicionales para el teclado.
            
        Returns:
            Un teclado inline configurado.
        """
        builder = InlineKeyboardBuilder()
        
        for row in buttons:
            for button_data in row:
                builder.button(
                    text=button_data['text'],
                    callback_data=button_data['callback_data']
                )
            # Agregar un ajuste manual de ancho despuÃ©s de cada fila
            if width:
                builder.adjust(width)
        
        return builder.as_markup(**kwargs)
    
    @staticmethod
    def create_reply(
        buttons: List[List[Dict[str, str]]],
        width: Optional[int] = None,
        resize_keyboard: bool = True,
        one_time_keyboard: bool = False,
        **kwargs
    ) -> types.ReplyKeyboardMarkup:
        """
        Crea un teclado de respuesta a partir de una matriz de botones.
        
        Args:
            buttons: Lista de filas de botones, donde cada botÃ³n es un diccionario
                    con 'text'.
            width: NÃºmero de botones por fila (si se utiliza la lista plana).
            resize_keyboard: Si el teclado debe ajustarse al tamaÃ±o de los botones.
            one_time_keyboard: Si el teclado debe ocultarse despuÃ©s de usarse.
            **kwargs: Argumentos adicionales para el teclado.
            
        Returns:
            Un teclado de respuesta configurado.
        """
        builder = ReplyKeyboardBuilder()
        
        for row in buttons:
            for button_data in row:
                builder.button(text=button_data['text'])
            # Agregar un ajuste manual de ancho despuÃ©s de cada fila
            if width:
                builder.adjust(width)
        
        return builder.as_markup(
            resize_keyboard=resize_keyboard,
            one_time_keyboard=one_time_keyboard,
            **kwargs
        )
    
    @classmethod
    def create(
        cls,
        keyboard_type: KeyboardType,
        buttons: List[List[Dict[str, str]]],
        **kwargs
    ) -> Union[types.InlineKeyboardMarkup, types.ReplyKeyboardMarkup]:
        """
        Crea un teclado del tipo especificado.
        
        Args:
            keyboard_type: Tipo de teclado a crear (INLINE o REPLY).
            buttons: Lista de filas de botones.
            **kwargs: Argumentos adicionales para el teclado.
            
        Returns:
            El teclado creado del tipo especificado.
            
        Raises:
            ValueError: Si el tipo de teclado no es vÃ¡lido.
        """
        if keyboard_type == KeyboardType.INLINE:
            return cls.create_inline(buttons, **kwargs)
        elif keyboard_type == KeyboardType.REPLY:
            return cls.create_reply(buttons, **kwargs)
        else:
            raise ValueError(f"Tipo de teclado no vÃ¡lido: {keyboard_type}")
    
    # MÃ©todos para crear teclados especÃ­ficos
    
    @classmethod
    def main_menu(cls) -> types.InlineKeyboardMarkup:
        """Crea el teclado del menÃº principal."""
        buttons = [
            [{"text": "ğŸ“œ Historia", "callback_data": "main_menu:narrative"}],
            [
                {"text": "ğŸ† Perfil", "callback_data": "main_menu:profile"},
                {"text": "ğŸ¯ Misiones", "callback_data": "main_menu:missions"}
            ],
            [{"text": "ğŸ’ Mochila", "callback_data": "main_menu:inventory"}],
            [{"text": "â“ Ayuda", "callback_data": "main_menu:help"}]
        ]
        return cls.create_inline(buttons)
    
    
<<<<<<< HEAD
=======
    @classmethod
    def wait_time_selection(cls) -> types.InlineKeyboardMarkup:
        """Crea el teclado para seleccionar el tiempo de espera."""
        buttons = [
            [
                {"text": "Inmediato", "callback_data": "admin:set_wait_time_0"},
                {"text": "15 min", "callback_data": "admin:set_wait_time_15"},
                {"text": "1 hora", "callback_data": "admin:set_wait_time_60"}
            ],
            [
                {"text": "12 horas", "callback_data": "admin:set_wait_time_720"},
                {"text": "24 horas", "callback_data": "admin:set_wait_time_1440"}
            ],
            [{"text": "â¬…ï¸ Volver", "callback_data": "admin:free_channel_menu"}]
        ]
        return cls.create_inline(buttons)
    
    @classmethod
    def post_confirmation(cls) -> types.InlineKeyboardMarkup:
        """Crea el teclado para confirmar un post."""
        buttons = [
            [{"text": "âœ… Enviar Post", "callback_data": "admin:confirm_post"}],
            [{"text": "âŒ Cancelar", "callback_data": "admin:cancel_post"}]
        ]
        return cls.create_inline(buttons)
    
>>>>>>> 9663835 (nuevo menu)
    
    @classmethod
    def narrative_menu(cls) -> types.InlineKeyboardMarkup:
        """Crea el teclado del menÃº de narrativa."""
        buttons = [
            [{"text": "ğŸ“– Continuar Historia", "callback_data": "narrative:continue"}],
            [{"text": "ğŸ” Explorar Ramas", "callback_data": "narrative:explore"}],
            [{"text": "ğŸ“œ Ver Fragmentos Desbloqueados", "callback_data": "narrative:fragments"}],
            [{"text": "â¬…ï¸ Volver al MenÃº Principal", "callback_data": "narrative:back_to_main"}]
        ]
        return cls.create_inline(buttons)
    
    @classmethod
    def missions_menu(cls) -> types.InlineKeyboardMarkup:
        """Crea el teclado del menÃº de misiones."""
        buttons = [
            [{"text": "ğŸ¯ Misiones Activas", "callback_data": "missions:active"}],
            [{"text": "âœ… Misiones Completadas", "callback_data": "missions:completed"}],
            [{"text": "ğŸ” Buscar Nuevas Misiones", "callback_data": "missions:find"}],
            [{"text": "â¬…ï¸ Volver al MenÃº Principal", "callback_data": "missions:back_to_main"}]
        ]
        return cls.create_inline(buttons)
    
    @classmethod
    def inventory_menu(cls) -> types.InlineKeyboardMarkup:
        """Crea el teclado del menÃº de inventario."""
        buttons = [
            [{"text": "ğŸ”® Objetos", "callback_data": "inventory:items"}],
            [{"text": "ğŸ… Logros", "callback_data": "inventory:achievements"}],
            [{"text": "ğŸ Recompensas", "callback_data": "inventory:rewards"}],
            [{"text": "â¬…ï¸ Volver al MenÃº Principal", "callback_data": "inventory:back_to_main"}]
        ]
        return cls.create_inline(buttons)
    
    @classmethod
    def help_menu(cls) -> types.InlineKeyboardMarkup:
        """Crea el teclado del menÃº de ayuda."""
        buttons = [
            [{"text": "ğŸ¤” CÃ³mo Jugar", "callback_data": "help:how_to_play"}],
            [{"text": "ğŸ“š Comandos", "callback_data": "help:commands"}],
            [{"text": "â“ Preguntas Frecuentes", "callback_data": "help:faq"}],
            [{"text": "â¬…ï¸ Volver al MenÃº Principal", "callback_data": "help:back_to_main"}]
        ]
        return cls.create_inline(buttons)
    
    @classmethod
    def back_button(cls, callback_data: str) -> types.InlineKeyboardMarkup:
        """
        Crea un teclado con un solo botÃ³n para volver.
        
        Args:
            callback_data: Callback data para el botÃ³n de volver.
        """
        buttons = [[{"text": "â¬…ï¸ Volver", "callback_data": callback_data}]]
        return cls.create_inline(buttons)
